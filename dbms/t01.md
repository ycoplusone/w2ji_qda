> ## [데이터베이스 인덱스의 오해와 진실](https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=52409)  
> 결합인덱스 : 2개 이상의 컬럼으로 인덱스를 구성한 경우
>> 1. 인덱스를 구성한 컬럼 순서대로 "=" 조건이 들어가야한다.   
>> 2. 결합인덱스를 구성할경우 "일자" 같은 컬럼은 후행에 자리 잡도록 인덱스를 구성해야 한다.  
>> 3. 결합인덱스를 구성할 경우 분포도가 나쁜 컬럼을 선행에 넣는것이 유리하다.  
>> #### - 공통적으로 사용하는 필수 조건절 컬럼을 우선.  
>> #### - "=" 조건의 컬럼을 다른 연사자 컬럼보다 우선한다.
>> #### - 대분류 , 중분류 , 소분류 컬럼순으로 구성한다.  
>> #### - 조건 정보 컬럼은 순서 정보 컬럼보다 우선한다.  
***
> ## [쉬운 것이 올바른 것이다. ‘인덱스 끝장리뷰’ (상)](https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=52402)
>> - 인덱스 대상 후보 컬럼 선정 기준
>> 1. 분포도가 좋은 컬럼 : 
>>> - 식별가능한 데이터 분포비율이 낮은것이 좋은 컬럼이다.  데이터의 분포도가 1% 이상이면 인덱스 효율성이 낮다.  
>> 2. 갱신(update)이 자주 발생하지 않는 컬럼.  
>>> - 갱신이 발생하는 컬럼의 경우 결합인덱스에서 후행에 넣는것이 바람직하다.  
>> 3. 조건절에서 자주 사용되는 컬럼.  
>>> - ![그림](https://dataonair.or.kr/publishing/img/knowledge/column_img_1434.jpg).  
>>> - 위 그림에서 처럼 조합과 빈도로 산출한다.    
>>> - 결합인덱스 = 컬럼3 + 컬럼4 + 컬럼6 + 컬럼7 순으로 생성하는것이 효율적이다.
>> 4. 조인의 연결고리에 사용되는 컬럼.  
>>> 오라클 쿼리에서 테이블간의 관계를 연결해주는 조인의 방법은 다음과 같이 3가지가 있다.    
>>> - nested loop join : 온라인 쿼리에서 90% 이상을 차지, 조인절에 인덱스가 반드시 있어야 한다.
>>> - sort merge join : 거의 발견할 수 없다. 조인절에 인덱스가 반드시 있어야 하는것은 아니다.  
>>> - Hash join : 배치쿼리에서 30% 이상을 차지, 조인절에 인덱스가 반드시 있어야하는것은 아니다.  
>>> ![인덱스 생성 이미지](https://dataonair.or.kr/publishing/img/knowledge/column_img_1435.jpg)
>>> 1번 위치에 인덱스를 생성할 경우 : 주문 테이블에서 고객 테이블로 접근(조인연결).  
>>> 2번 위치에 인덱스를 생성할 경우 : 고객 테이블에서 주문 테이블로 접근(조인연결).  
>>> 1번, 2번 위치에 모두다 있을 경우 : 오라클에서 통계 정보를 바탕으로 테이블간 방향을 결정.  
>>> 1번,2번 위치에 모두다 없을 경우 :  sort merge join 방식이나 Hash join 방식으로 플랜이 결정.  
>> 5. sort 발생을 제거하는 컬럼.  
>>> 하나의 테이블에 인덱스가 많으면 많을 수록 부하가 점점 증가 하듯이 결합인덱스도 컬럼 수가 많으면 부하가 점점 증가한다.  
>>> 결합인덱스에 조건절 컬럼 이외에 order by 절 컬럼을 추가할 때 발생하는 인덱스 부하와 추가하지 않때 sort 부하를 비교해 결정한다.  
>>> 쿼리의 조건에 과 ORDER BY 까지 확인해서 결합인덱스를 생성한다.  
***  
> ## [쉬운 것이 올바른 것이다. ‘인덱스 끝장리뷰’ (하)](https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=52396)
>> - 인덱스 수는 적정해야 한다.  
>>> 1. 코드성 테이블: 필요한 만큼 인덱스 생성 가능(인덱스 경합이 발생하지 않도록 주의).  
>>>> - 마스터 테이블 같은경우 필요한 만큼 생성한다, 단 인덱스 경합이 발생할수 있으므로 주의하자.  
>>> 2. 처리성 테이블 : 최소한으로 사용(대용량 테이블이라면 가능한 적게).  
>>>> - core 테이블 같은 경우 인덱스는 최소한으로 한다, 빈번한 cud가 발생 하나 인덱스를 최소화 한다.  
>>> 3. 집계성 테이블 : 필요한 만큼 적정하게 사용.  
>>>> - dw테이블을 의미한다 .  
>>>> - 데이터 집계 처리에 대한 부담보다는 조회에  비중이 있는 테이블이므로 인덱스가 많아도 무방하다.  
>>> 4. 로그성 테이블 : 필요 없음(필요에 따라서 하나 정도는 존재할수도 있음).  
>>>> - 시간정보에 대한 인덱스 정도면 충분하다.  
>> ***
>> - 해당 테이블에 인덱스가 너무 많다면, 인덱스 생성 여부를 결정하는 요소가 될수있다.  
>>> 1. 쿼리 구동 시간이 낮인지 밤인지에 따라서 인덱스 생성 여루ㅂ를 결정할수 있다(온라인, 배치).  
>>> 2. 누가 사용하는지에 따라서 인덱스 생성 여부를 결정 할수 있다(담당자 , 관리자, 사장).  
>>> 3. 얼마나 많이 구동되는지에 따라서 인덱스 생성 여부를 결정할 수 있다.  
>>> 4. 소형 테이블인 경우 인덱스는 있어야 한다.  
>> ***  
>> - 인덱스는 위치정보와 순서정보로 구성됐다.  
>> - 조건절에 사용하는 인덱스와 조인절에 사용하는 인덱스.  
>>> 1. 1:n 관계의 테이블 조인에서는 오히려 접근 범위가 커지기도한다.  
>>> 2. 쿼리에서는 조건절 인덱스가 최초로 접근하는 테이블을 결정한다.  
>>> 3. join 하는 테이블에 인덱스가 없는것이 where 하는 기준테이블에 인덱스 없는것보다 성능에 문제를 발생시킬수 있다.  
>> - 인덱스 생성/삭제 시 고려사항 : 인덱스는 만들때나 삭제할때 언제나 신중하게 접근하는것이 필요하다.  
>> 1. 신규 인덱스 생성하기 전에 유사 인덱스가 존재하는지 확인한다.  
>>> - 유사한 인덱스끼리 경합이 발생할 수도 있고, 기존 쿼리의 플랜이 변동하여 성능상에 문제가 발생할수 있다.  
>> 2. 신규인덱스 생성하기전에 index split을 유발하지 않는지 확인한다.  
>>> - 인덱스 분류 작업이 한곳으로 집중되어서, 동일한 leaf block에 대해 과도한 split이 발생한다면 성능상의 문제가 발생한다. Reverse index를 이용해서 해결한다.  
>> 3. 신규인덱스 생성하기 전에 CBO 방식에서의 통계정보가 최신인지 확인한다.  
>>> - 통계정보와 실제 데이터의 차이가 현저하기 발생하면 인덱를 이용하지 못할수 있다.  
>> 4. 기존 인덱스 삭제하기 전에 사용하지 않는 미사용 인덱스인지 반드시 확인한다.  
>>> - .  
